<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>MessageService-JavaDoc</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">MessageService-JavaDoc</h1>
</header>
<h3 id="messageservice.java"><code>MessageService.java</code></h3>
<p><strong>1. 概述 (Overview)</strong></p>
<p><strong>完整路径:</strong>
<code>cn.drcomo.corelib.message.MessageService</code></p>
<p><strong>核心职责:</strong> <code>MessageService</code>
是插件内所有文本消息的集中式“大脑”，负责本地化、多语言支持、占位符解析、颜色转换、多渠道发送、上下文消息缓存等一整套统一的消息处理逻辑，解决以下常见痛点：</p>
<ol type="1">
<li><p><strong>本地化与多语言支持</strong></p>
<ul>
<li>从 YAML 语言文件加载键值（支持热重载/切换语言文件）。</li>
<li>全量缓存到内存中，保证读取性能为 O(1)。</li>
<li>语言文件路径按需指定，可结合 <code>keyPrefix</code>
自动补全键前缀，防止重复书写。</li>
</ul></li>
<li><p><strong>多层占位符解析（链路清晰，顺序明确）</strong></p>
<ul>
<li><p><strong>格式化替换（Java <code>String.format</code> /
<code>{}</code> 顺序占位符）</strong>：仅在显式调用含格式参数的方法（如
<code>get(key, args...)</code>、<code>sendChat</code>
等）中执行。</p></li>
<li><p><strong>占位符链替换（custom → internal → extra regex →
PlaceholderAPI → 颜色）</strong>：由 <code>parseWithDelimiter</code>
系列方法驱动，按顺序依次处理并最终执行颜色翻译。</p>
<ul>
<li><strong>custom</strong>：自定义占位符，支持任意前后缀分隔符（默认
<code>%</code> 与 <code>%</code>）。</li>
<li><strong>internal</strong>：内部占位符
<code>{key[:args]}</code>，通过注册 resolver 扩展。</li>
<li><strong>extra
regex</strong>：额外正则替换规则，按注册顺序链式作用。</li>
<li><strong>PlaceholderAPI</strong>：解析 <code>%player_name%</code>
等上下文相关占位符。</li>
<li><strong>颜色</strong>：统一调用
<code>ColorUtil.translateColors</code> 转换 <code>&amp;</code> 颜色符为
<code>§</code>。</li>
</ul></li>
</ul></li>
<li><p><strong>颜色统一转换</strong></p>
<ul>
<li>所有玩家输出路径都强制颜色转换，外部调用无需手动处理。</li>
<li>支持渐变色与高级颜色格式，建议对相对静态内容提前做颜色解析并缓存。</li>
</ul></li>
<li><p><strong>多渠道发送</strong></p>
<ul>
<li>聊天、ActionBar、Title/SubTitle、广播（支持权限过滤）、上下文聚合分发。</li>
<li>发送 API 会在异步调用时自动切回主线程，保障 Bukkit API 安全。</li>
</ul></li>
<li><p><strong>上下文消息缓存与语义分流</strong></p>
<ul>
<li>支持缓存成功流与失败流的消息（<code>sendContextSuccesses</code> /
<code>sendContextFailures</code>），调用后统一发送。</li>
<li>语义分流 API 当前实现一致，便于未来扩展样式而不修改调用方。</li>
</ul></li>
<li><p><strong>日志与容错策略</strong></p>
<ul>
<li>缺失
key、格式化失败、空列表、解析异常等情况均会记录日志（warn/error），但不会抛出异常中断调用。</li>
<li>解析失败或缺失内容会退回原文或 null，调用方可安全处理。</li>
</ul></li>
<li><p><strong>性能考量</strong></p>
<ul>
<li>全量缓存语言内容，避免频繁 I/O。</li>
<li>如果 resolver 执行昂贵计算（I/O、大量逻辑），建议在 resolver
内自行缓存或限流。</li>
<li>建议使用内置的 <code>storeMessage*</code> +
<code>sendContext*</code> 组合，减少重复循环。</li>
</ul></li>
<li><p><strong>线程安全</strong></p>
<ul>
<li>内部数据结构（<code>HashMap</code> /
<code>ArrayList</code>）非线程安全。</li>
<li>多线程环境下读取与写入（如 reload）需上层调度控制，避免竞争。</li>
<li>主线程安全已在发送 API 内保障，但语言文件 reload
建议在主线程执行。</li>
<li>如需并发安全，可考虑 <code>ConcurrentHashMap</code> 或加锁。</li>
</ul></li>
</ol>
<hr />
<p><strong>2. 如何实例化 (Initialization)</strong></p>
<p><strong>核心思想:</strong> <code>MessageService</code>
依赖多个组件（日志、YAML 配置加载器、PlaceholderAPI
封装），需要按顺序准备好并组合构造，才能正常工作。</p>
<p><strong>构造函数签名:</strong></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="fu">MessageService</span><span class="op">(</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    Plugin plugin<span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    DebugUtil logger<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    YamlUtil yamlUtil<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    PlaceholderAPIUtil placeholderUtil<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span> langConfigPath<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span> keyPrefix</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p><strong>参数说明:</strong></p>
<ul>
<li><code>plugin</code>：插件主类实例，当前未直接使用但保留作扩展用途。</li>
<li><code>logger</code>：调试与日志输出工具，记录 info/warn/error。</li>
<li><code>yamlUtil</code>：YAML
文件加载与访问工具，负责语言文件的解析与监听。</li>
<li><code>placeholderUtil</code>：PlaceholderAPI 封装工具，处理
<code>%...%</code> 类上下文占位符。</li>
<li><code>langConfigPath</code>：语言文件路径（不带 <code>.yml</code>
后缀），如 <code>"languages/zh_CN"</code> 对应
<code>languages/zh_CN.yml</code>。</li>
<li><code>keyPrefix</code>：查找 key 前自动拼接的前缀，null
会归一为空字符串；<code>resolveKey</code> 会检测避免重复拼接。</li>
</ul>
<p><strong>初始化流程:</strong></p>
<ol type="1">
<li>使用 <code>yamlUtil.loadConfig(langConfigPath)</code>
加载语言文件。</li>
<li>将所有键值对缓存到内存中的 <code>messages</code>。</li>
<li>所有消息获取与解析方法直接基于内存缓存执行，避免运行时 I/O。</li>
</ol>
<p><strong>示例：</strong></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>DebugUtil logger        <span class="op">=</span> <span class="kw">new</span> <span class="fu">DebugUtil</span><span class="op">(</span><span class="kw">this</span><span class="op">,</span> DebugUtil<span class="op">.</span><span class="fu">LogLevel</span><span class="op">.</span><span class="fu">INFO</span><span class="op">);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>YamlUtil yamlUtil       <span class="op">=</span> <span class="kw">new</span> <span class="fu">YamlUtil</span><span class="op">(</span><span class="kw">this</span><span class="op">,</span> logger<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>PlaceholderAPIUtil papi <span class="op">=</span> <span class="kw">new</span> <span class="fu">PlaceholderAPIUtil</span><span class="op">(</span><span class="kw">this</span><span class="op">,</span> <span class="st">&quot;example&quot;</span><span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>MessageService ms <span class="op">=</span> <span class="kw">new</span> <span class="fu">MessageService</span><span class="op">(</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    logger<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    yamlUtil<span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    papi<span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;languages/zh_CN&quot;</span><span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;messages.example.&quot;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>ms<span class="op">.</span><span class="fu">registerInternalPlaceholder</span><span class="op">(</span><span class="st">&quot;online&quot;</span><span class="op">,</span> <span class="op">(</span>player<span class="op">,</span> args<span class="op">)</span> <span class="op">-&gt;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span><span class="op">.</span><span class="fu">valueOf</span><span class="op">(</span>Bukkit<span class="op">.</span><span class="fu">getOnlinePlayers</span><span class="op">().</span><span class="fu">size</span><span class="op">())</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p><strong>常见误用与注意点:</strong></p>
<ul>
<li><code>langConfigPath</code> 不可带 <code>.yml</code> 后缀。</li>
<li>修改语言文件后需调用 <code>reloadLanguages()</code>
才能应用新内容。</li>
<li>如果 <code>keyPrefix</code> 已存在于传入 key 中，不会重复添加。</li>
</ul>
<hr />
<p><strong>3. 占位符解析机制（内部细节）</strong></p>
<p><strong>解析链路总览：</strong> 占位符替换分为两大类路径：</p>
<ol type="1">
<li><strong>格式化替换（Java 原生格式化）</strong>
<ul>
<li>在
<code>get(key, args...)</code>、<code>sendChat</code>、<code>sendActionBar</code>
等显式方法中调用。</li>
<li>使用 <code>%s</code> 或 <code>{}</code> 顺序占位符，替换逻辑与 Java
标准一致。</li>
</ul></li>
<li><strong>占位符链替换（自定义链路）</strong>
<ul>
<li>由 <code>parseWithDelimiter</code>
及其衍生方法驱动，按以下顺序执行：
<ol type="1">
<li><strong>Custom 占位符替换</strong>：基于传入的 prefix/suffix（默认
<code>%...%</code>）在 custom map 中替换。</li>
<li><strong>Internal 占位符替换</strong>：<code>{key[:args]}</code>
格式，匹配后调用已注册的 resolver。</li>
<li><strong>Extra Regex
替换</strong>：用户注册的正则规则链式执行，后注册的规则处理前规则的结果。</li>
<li><strong>PlaceholderAPI 替换</strong>：解析 Bukkit 上下文相关的
<code>%...%</code> 占位符。</li>
<li><strong>颜色解析</strong>：调用
<code>ColorUtil.translateColors</code> 处理颜色符。</li>
</ol></li>
</ul></li>
</ol>
<p><strong>占位符注册与管理:</strong></p>
<ul>
<li><p><strong>内部占位符注册</strong></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">registerInternalPlaceholder</span><span class="op">(</span><span class="bu">String</span> key<span class="op">,</span> PlaceholderResolver resolver<span class="op">)</span></span></code></pre></div>
<ul>
<li>key 小写匹配，不带 <code>{}</code>。</li>
<li>resolver 参数为 <code>(Player, String[] args)</code>。</li>
<li>未注册的占位符会原样保留。</li>
</ul></li>
<li><p><strong>额外正则规则注册</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">addPlaceholderRule</span><span class="op">(</span><span class="bu">Pattern</span> pattern<span class="op">,</span> BiFunction<span class="op">&lt;</span>Player<span class="op">,</span> <span class="bu">Matcher</span><span class="op">,</span> <span class="bu">String</span><span class="op">&gt;</span> resolver<span class="op">)</span></span></code></pre></div>
<ul>
<li>可匹配任意模式（如 <code>{{var}}</code>）。</li>
<li>替换顺序严格按注册顺序执行。</li>
<li>需注意链式效果可能造成二次替换或冲突。</li>
</ul></li>
<li><p><strong>自定义分隔符</strong></p>
<ul>
<li>默认分隔符为 <code>%</code> 与 <code>%</code>，可通过
<code>setDefaultCustomDelimiters("{", "}")</code> 等方法修改。</li>
<li>修改后相关方法（如 <code>parseList</code>、<code>broadcast</code>
等）会使用新的默认分隔符。</li>
</ul></li>
</ul>
<p><strong>行为细节与建议:</strong> * <strong>前缀自动补全逻辑</strong>
* <code>resolveKey</code> 检查传入 key 是否已包含
<code>keyPrefix</code>，防止重复拼接。</p>
<ul>
<li><strong>日志策略</strong>
<ul>
<li>缺失 key：<code>getRaw</code> 日志 warn 并返回 null。</li>
<li>格式化失败：捕获 <code>IllegalFormatException</code>，error
日志并返回未格式化字符串。</li>
<li>空列表：<code>getList</code> 返回空时 warn，提示可能 key
写错或文件缺失。</li>
</ul></li>
<li><strong>占位符/规则冲突处理</strong>
<ul>
<li>替换顺序为 custom → internal → regex → PlaceholderAPI → 颜色。</li>
<li>Extra regex 为链式，注册顺序影响最终结果。</li>
<li>Internal placeholder 与 regex 可能交叠，复杂情况建议加防重逻辑或精确
pattern。</li>
</ul></li>
<li><strong>性能优化建议</strong> <strong>(重点)</strong>
<ul>
<li>对相对静态的键，建议在配置加载阶段提前调用
<code>ColorUtil.translateColors</code> 进行颜色解析，并缓存结果。</li>
<li>占位符 resolver 中涉及昂贵操作应加缓存或限流。</li>
</ul></li>
</ul>
<p><strong>容错语义：</strong> * <code>getRaw</code>：缺失返回 null。 *
<code>get</code>：格式化异常降级返回原文。 *
<code>parseWithDelimiter</code>：缺失 key 返回 null。 * 发送接口：遇到
null 多数会静默跳过。 * 非 Player 调用 Player 上下文方法时，player
参数为 null，占位符解析会退化执行。</p>
<hr />
<p><strong>4. 主要公共 API 方法</strong></p>
<h4 id="语言与前缀控制">语言与前缀控制</h4>
<ul>
<li><h4 id="reloadlanguages"><code>reloadLanguages()</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> 从磁盘重新加载当前语言文件（由
<code>langConfigPath</code>
指定），并刷新内存中的消息缓存。此操作会先清空旧缓存，再从文件加载新内容。</li>
<li><strong>调用建议:</strong>
当语言文件在外部被修改后，或需要通过指令热重载配置时调用。建议在主线程执行以避免线程安全问题。</li>
<li><strong>最佳实践（性能）:</strong> 重载后对“相对静态”模板执行一次
<code>ColorUtil.translateColors(...)</code>
并缓存；发送阶段仅做占位符替换。</li>
</ul></li>
<li><h4
id="switchlanguagestring-newpath"><code>switchLanguage(String newPath)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
动态切换到另一个语言文件。该方法会更新内部的
<code>langConfigPath</code>，然后自动调用 <code>reloadLanguages()</code>
来加载新文件。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>newPath</code> (<code>String</code>):
新的语言文件路径，相对于插件数据文件夹，且<strong>不</strong>包含
<code>.yml</code> 后缀（例如 <code>"languages/en_US"</code>）。</li>
</ul></li>
</ul></li>
<li><h4
id="setkeyprefixstring-newprefix"><code>setKeyPrefix(String newPrefix)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
动态设置或更改所有消息键（key）的统一前缀。在后续调用
<code>get</code>、<code>send</code>
等方法时，此前缀会自动拼接到传入的键之前（除非键本身已包含该前缀）。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>newPrefix</code> (<code>String</code>): 新的键前缀。如果传入
<code>null</code>，将被视为空字符串 <code>""</code>。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="获取与解析">获取与解析</h4>
<ul>
<li><h4 id="getrawstring-key"><code>getRaw(String key)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>String</code></li>
<li><strong>功能描述:</strong>
根据键名获取在语言文件中定义的、未经任何处理的原始字符串。此方法会经过
<code>resolveKey</code> 自动添加前缀。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 消息键。</li>
</ul></li>
<li><strong>返回值:</strong> 找到则返回原始字符串，否则返回
<code>null</code> 并记录警告。</li>
</ul></li>
<li><h4
id="getstring-key-object...-args"><code>get(String key, Object... args)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>String</code></li>
<li><strong>功能描述:</strong> 获取原始字符串后，使用
<code>String.format</code> 进行 Java 风格的格式化（替换 <code>%s</code>,
<code>%d</code> 等）。此方法<strong>不</strong>执行占位符链解析。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 消息键。</li>
<li><code>args</code> (<code>Object...</code>):
用于格式化字符串的可变参数。</li>
</ul></li>
<li><strong>返回值:</strong>
格式化后的字符串。若原始消息未找到，返回错误提示；若格式化失败，返回原始字符串并记录错误。</li>
</ul></li>
<li><h4
id="parsewithdelimiterstring-key-player-player-mapstring-string-custom-string-prefix-string-suffix"><code>parseWithDelimiter(String key, Player player, Map&lt;String, String&gt; custom, String prefix, String suffix)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>String</code></li>
<li><strong>功能描述:</strong>
获取指定键的消息，并执行完整的占位符解析链（自定义占位符 -&gt;
内部占位符 -&gt; 正则规则 -&gt;
PlaceholderAPI），最后进行颜色代码翻译。这是最核心的消息处理方法。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 消息键。</li>
<li><code>player</code> (<code>Player</code>): 消息接收者，用于
PlaceholderAPI 上下文。可为 <code>null</code>。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符的键值对。</li>
<li><code>prefix</code> (<code>String</code>): 自定义占位符的前缀，例如
<code>"%"</code>。</li>
<li><code>suffix</code> (<code>String</code>): 自定义占位符的后缀，例如
<code>"%"</code>。</li>
</ul></li>
<li><strong>返回值:</strong>
完全处理好、可直接发送给玩家的最终字符串。若键不存在则返回
<code>null</code>。</li>
</ul></li>
<li><h4 id="getliststring-key"><code>getList(String key)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>List&lt;String&gt;</code></li>
<li><strong>功能描述:</strong>
从语言文件中获取一个字符串列表，通常用于定义多行消息（如 Hologram、Lore
等）。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 消息列表的键。</li>
</ul></li>
<li><strong>返回值:</strong>
原始的字符串列表。若键不存在或对应的值不是列表，返回空列表。</li>
</ul></li>
<li><h4
id="parseliststring-key-player-player-mapstring-string-custom"><code>parseList(String key, Player player, Map&lt;String, String&gt; custom)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>List&lt;String&gt;</code></li>
<li><strong>功能描述:</strong>
获取一个消息列表，并对其中的每一行字符串独立执行完整的占位符解析和颜色翻译。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 消息列表的键。</li>
<li><code>player</code> (<code>Player</code>): 消息接收者上下文。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符，作用于列表中的每一行。</li>
</ul></li>
<li><strong>返回值:</strong> 解析完成的字符串列表，可直接逐行发送。</li>
</ul></li>
</ul>
<h4 id="发送接口聊天-actionbar-title">发送接口（聊天 / ActionBar /
Title）</h4>
<ul>
<li><h4
id="sendcommandsender-target-string-key-mapstring-string-custom"><code>send(CommandSender target, String key, Map&lt;String, String&gt; custom)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
解析语言文件中的消息并将其作为聊天消息发送给指定目标（玩家或控制台）。这是最常用的发送方法之一。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>target</code> (<code>CommandSender</code>): 消息接收者。</li>
<li><code>key</code> (<code>String</code>): 语言文件中的消息键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符键值对。</li>
</ul></li>
</ul></li>
<li><h4
id="sendplayer-player-string-template-mapstring-string-custom-string-prefix-string-suffix"><code>send(Player player, String template, Map&lt;String, String&gt; custom, String prefix, String suffix)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
直接使用给定的字符串模板进行解析并发送，不经过语言文件查询。适用于动态生成的消息内容。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>player</code> (<code>Player</code>): 目标玩家。</li>
<li><code>template</code> (<code>String</code>): 消息模板原文。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>prefix</code> (<code>String</code>): 占位符前缀。</li>
<li><code>suffix</code> (<code>String</code>): 占位符后缀。</li>
</ul></li>
</ul></li>
<li><h4
id="sendchatplayer-player-string-template-object...-args"><code>sendChat(Player player, String template, Object... args)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> 使用 <code>{}</code>
作为顺序占位符，对模板进行快速替换后，作为聊天消息发送给玩家。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>player</code> (<code>Player</code>): 目标玩家。</li>
<li><code>template</code> (<code>String</code>): 含 <code>{}</code>
占位符的消息模板。</li>
<li><code>args</code> (<code>Object...</code>): 按顺序替换
<code>{}</code> 的参数。</li>
</ul></li>
</ul></li>
<li><h4
id="sendactionbarplayer-player-string-template-..."><code>sendActionBar(Player player, String template, ...)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> 将解析后的消息通过 ActionBar
发送给玩家。提供多个重载版本，分别支持从语言键、直接模板+自定义占位符、直接模板+<code>{}</code>顺序占位符三种方式生成内容。</li>
<li><strong>参数说明:</strong> (以
<code>sendActionBar(Player, String, Map, String, String)</code> 为例)
<ul>
<li><code>player</code> (<code>Player</code>): 目标玩家。</li>
<li><code>template</code> (<code>String</code>): 消息模板。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>prefix</code> (<code>String</code>): 占位符前缀。</li>
<li><code>suffix</code> (<code>String</code>): 占位符后缀。</li>
</ul></li>
</ul></li>
<li><h4
id="sendtitleplayer-player-string-titletemplate-string-subtemplate-..."><code>sendTitle(Player player, String titleTemplate, String subTemplate, ...)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> 将解析后的主标题和副标题通过
Title/SubTitle
的形式发送给玩家。同样提供多个重载版本，支持从语言键、直接模板+自定义占位符、直接模板+<code>{}</code>顺序占位符三种方式生成内容。</li>
<li><strong>参数说明:</strong> (以
<code>sendTitle(Player, String, String, Map, String, String)</code>
为例)
<ul>
<li><code>player</code> (<code>Player</code>): 目标玩家。</li>
<li><code>titleTemplate</code> (<code>String</code>): 主标题模板。</li>
<li><code>subTemplate</code> (<code>String</code>): 副标题模板。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符（同时作用于主副标题）。</li>
<li><code>prefix</code> (<code>String</code>): 占位符前缀。</li>
<li><code>suffix</code> (<code>String</code>): 占位符后缀。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="列表-批量发送">列表 / 批量发送</h4>
<ul>
<li><h4
id="sendlistcommandsender-target-string-key-mapstring-string-custom"><code>sendList(CommandSender target, String key, Map&lt;String, String&gt; custom)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
解析语言文件中一个键对应的消息列表，并将每一行作为单独的聊天消息发送给目标。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>target</code> (<code>CommandSender</code>): 消息接收者。</li>
<li><code>key</code> (<code>String</code>):
语言文件中的消息列表键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符，作用于列表中的每一行。</li>
</ul></li>
</ul></li>
<li><h4
id="sendlistcommandsender-target-liststring-templates-mapstring-string-custom-string-prefix-string-suffix"><code>sendList(CommandSender target, List&lt;String&gt; templates, Map&lt;String, String&gt; custom, String prefix, String suffix)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
对一个给定的字符串模板列表进行逐行解析，并将结果作为多行聊天消息发送。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>target</code> (<code>CommandSender</code>): 消息接收者。</li>
<li><code>templates</code> (<code>List&lt;String&gt;</code>):
原始模板列表。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>prefix</code> (<code>String</code>): 占位符前缀。</li>
<li><code>suffix</code> (<code>String</code>): 占位符后缀。</li>
</ul></li>
</ul></li>
<li><h4
id="sendrawcommandsender-target-string-rawmessage"><code>sendRaw(CommandSender target, String rawMessage)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
发送一条未经任何占位符解析的原始字符串，但依然会进行颜色代码翻译。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>target</code> (<code>CommandSender</code>): 消息接收者。</li>
<li><code>rawMessage</code> (<code>String</code>):
要发送的原始消息。</li>
</ul></li>
</ul></li>
<li><h4
id="sendrawlistcommandsender-target-liststring-rawmessages"><code>sendRawList(CommandSender target, List&lt;String&gt; rawMessages)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
发送一个原始字符串列表，对每行仅做颜色翻译后逐一发送。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>target</code> (<code>CommandSender</code>): 消息接收者。</li>
<li><code>rawMessages</code> (<code>List&lt;String&gt;</code>):
要发送的原始消息列表。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="广播">广播</h4>
<ul>
<li><h4
id="broadcaststring-key-mapstring-string-custom-string-permission"><code>broadcast(String key, Map&lt;String, String&gt; custom, String permission)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
向服务器上的所有玩家（或拥有特定权限的玩家）广播一条消息。消息内容从语言文件获取并解析。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>key</code> (<code>String</code>): 语言文件中的消息键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>permission</code> (<code>String</code>):
权限节点。如果提供，则只有拥有此权限的玩家才会收到广播。可为
<code>null</code>。</li>
</ul></li>
</ul></li>
<li><h4
id="broadcaststring-template-mapstring-string-custom-string-prefix-string-suffix-string-permission"><code>broadcast(String template, Map&lt;String, String&gt; custom, String prefix, String suffix, String permission)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
使用直接的模板向全服（或部分玩家）广播，不查询语言文件。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>template</code> (<code>String</code>): 消息模板。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>prefix</code> (<code>String</code>): 占位符前缀。</li>
<li><code>suffix</code> (<code>String</code>): 占位符后缀。</li>
<li><code>permission</code> (<code>String</code>): 可选的权限节点。</li>
</ul></li>
</ul></li>
<li><h4
id="broadcaststring-key-mapstring-string-custom-string-permission-1"><code>broadcast(String key, Map&lt;String, String&gt; custom, String permission)</code></h4>
<ul>
<li>行为更新：该方法会使用通过 <code>setDefaultCustomDelimiters</code>
配置的默认分隔符对 custom map 进行解析（默认仍为
<code>%</code>），兼容旧版本行为并可按需切换到 <code>{}</code>。</li>
</ul></li>
<li><h4
id="broadcastbykeystring-key-mapstring-string-custom-string-prefix-string-suffix"><code>broadcastByKey(String key, Map&lt;String, String&gt; custom, String prefix, String suffix)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
使用语言键并指定分隔符解析，然后向全服广播。</li>
<li><strong>参数说明:</strong> 同 <code>parseWithDelimiter</code> 的
<code>prefix/suffix</code> 规则。</li>
</ul></li>
<li><h4
id="broadcastbykeystring-key-mapstring-string-custom-string-prefix-string-suffix-string-permission"><code>broadcastByKey(String key, Map&lt;String, String&gt; custom, String prefix, String suffix, String permission)</code></h4>
<ul>
<li><p><strong>返回类型:</strong> <code>void</code></p></li>
<li><p><strong>功能描述:</strong>
使用语言键并指定分隔符解析，然后仅向拥有指定权限的玩家广播。</p></li>
<li><p><strong>参数说明:</strong> 同上，并附加
<code>permission</code>。</p></li>
<li><p><strong>返回类型:</strong> <code>void</code></p></li>
<li><p><strong>功能描述:</strong>
广播一个来自语言文件的多行消息列表，每行独立发送。</p></li>
<li><p><strong>参数说明:</strong></p>
<ul>
<li><code>key</code> (<code>String</code>): 消息列表的键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
<li><code>permission</code> (<code>String</code>): 可选的权限节点。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="上下文消息聚合-分流">上下文消息（聚合 / 分流）</h4>
<ul>
<li><h4
id="storemessageobject-context-string-key-mapstring-string-custom"><code>storeMessage(Object context, String key, Map&lt;String, String&gt; custom)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> 将一条解析后的消息暂存到由
<code>context</code>
对象标识的缓存区中，而不是立即发送。用于聚合多个步骤产生的消息。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>):
任意用作上下文标识符的对象（如 <code>Player</code>
实例、<code>UUID</code> 或自定义命令对象）。</li>
<li><code>key</code> (<code>String</code>): 消息键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
</ul></li>
</ul></li>
<li><h4
id="storemessagelistobject-context-string-key-mapstring-string-custom"><code>storeMessageList(Object context, String key, Map&lt;String, String&gt; custom)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
将一个解析后的多行消息列表暂存到上下文缓存中。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>): 上下文标识符。</li>
<li><code>key</code> (<code>String</code>): 消息列表的键。</li>
<li><code>custom</code> (<code>Map&lt;String, String&gt;</code>):
自定义占位符。</li>
</ul></li>
</ul></li>
<li><h4
id="hasmessagesobject-context"><code>hasMessages(Object context)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>boolean</code></li>
<li><strong>功能描述:</strong>
检查指定的上下文缓存中是否包含任何待发送的消息。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>): 上下文标识符。</li>
</ul></li>
<li><strong>返回值:</strong> 如果缓存中有消息，则为
<code>true</code>，否则为 <code>false</code>。</li>
</ul></li>
<li><h4
id="countmessagesobject-context"><code>countMessages(Object context)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>int</code></li>
<li><strong>功能描述:</strong> 获取指定上下文缓存中的消息数量。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>): 上下文标识符。</li>
</ul></li>
<li><strong>返回值:</strong> 缓存的消息行数。</li>
</ul></li>
<li><h4
id="sendcontextobject-context-player-player-string-channel"><code>sendContext(Object context, Player player, String channel)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong>
将指定上下文缓存中的所有消息，通过特定渠道（如聊天、ActionBar）一次性发送给玩家，并清空该上下文的缓存。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>): 上下文标识符。</li>
<li><code>player</code> (<code>Player</code>): 消息接收者。</li>
<li><code>channel</code> (<code>String</code>): 发送渠道，支持
<code>"chat"</code>, <code>"actionbar"</code>,
<code>"title"</code>。</li>
</ul></li>
</ul></li>
<li><h4
id="sendcontextsuccessesobject-context-player-player-sendcontextfailuresobject-context-player-player"><code>sendContextSuccesses(Object context, Player player)</code>
/ <code>sendContextFailures(Object context, Player player)</code></h4>
<ul>
<li><strong>返回类型:</strong> <code>void</code></li>
<li><strong>功能描述:</strong> <code>sendContext</code>
的语义化别名，用于在代码逻辑中清晰地标识发送的是成功反馈还是失败反馈。当前它们的实现与
<code>sendContext(context, player, "chat")</code>
等价，但为未来扩展不同渠道或样式提供了接口。</li>
<li><strong>参数说明:</strong>
<ul>
<li><code>context</code> (<code>Object</code>): 上下文标识符。</li>
<li><code>player</code> (<code>Player</code>): 消息接收者。</li>
</ul></li>
</ul></li>
</ul>
</body>
</html>
